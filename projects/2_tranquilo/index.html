<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>tranquilo | Janoś Gabler</title> <meta name="author" content="Janoś Gabler"/> <meta name="description" content="An optimizer that enables domain experts to solve noisy optimization problems."/> <meta name="keywords" content="Janos Gabler, Python, Economics, estimagic"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚛️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://janosg.github.io/projects/2_tranquilo/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://janosg.github.io/"><span class="font-weight-bold">Janoś</span> Gabler</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">tranquilo</h1> <p class="post-description">An optimizer that enables domain experts to solve noisy optimization problems.</p> </header> <article> <h2 id="motivation">Motivation</h2> <p>Throughout my PhD I had to solve several difficult optimization problems. The most difficult one was fitting the parameters of an agent-based <a href="https://www.nature.com/articles/s41598-022-12015-9" target="_blank" rel="noopener noreferrer">Covid Model</a> to German time Series of infections and fatalities.</p> <p>There were two main difficulties:</p> <ol> <li>The objective function was very noisy</li> <li>The computational bottleneck of the model was inherently serial</li> </ol> <p>None of the optimizers I tried (and I tried many!) worked and I could only solve the the problem with a lot of manual intervention. To make sure I’ll never have to go through this again, we developed Tranquilo, a derivative free trustregion optimizer for noisy objective functions that can do function evaluations in parallel.</p> <p>A particular focus was on making tranquilo useful for domain experts, i.e. scientists who are experts in some field, but have no formal training in numerical optimization or parallel programming.</p> <h2 id="derivative-free-trustregion-optimization">Derivative Free Trustregion Optimization</h2> <p>Let’s start with a short introduction to derivative free trustregion optimization. Instead of showing the math, I will try a visual explanation of how such an optimizer minimizes the function along with a verbal description. Consider the objective function:</p> \[f(x, y) = x^2 + y^2\] <p>The global optimum of this function is at \(x=0, y=0\).</p> <p>In general, derivative free trustregion optimizers start by fixing a parameter vector \(x_0\) which is the center of the trustregion and a trustregion radius \(\delta_0\). They then sample parameter vectors inside the trustregion or close by, evaluate the objective function on each point in the sample and fit an approximation to the objective function by interpolation or regression. This approximation is called the surrogate model.</p> <p>This surrogate model is then minimized over the trustregion and the argmin of the surrogate model is the next candidate point. In the plot below, the blue point is the trustregion center, the red points are newly sampled points and the green star is the argmin of the surrogate model.</p> <p><img src="/assets/img/tranquilo/animation_1.svg" class="rounded" width="700"></p> <p>The surrogate model does not only give us a candidate point but also a prediction for the improvement we can expect. After evaluating the objective function at the candidate point, we can compare this expected improvement to the actual improvement and get:</p> \[\rho = \frac{\text{actual improvement}}{\text{expected improvement}}\] <p>As long as the actual improvement is positive, we keep the new point. Depending on \(\rho\) we also adjust the the trustregion radius for the next iteration:</p> <p>If \(\rho\) is satisfactorily large, say above \(0.2\) the model is good and we increase the radius. If it is small, we decrease the radius. This works (in the absence of noise) because we typically choose surrogate models with taylor like error bounds, i.e. the model can approximate the objective function arbitrarily well as long as we make the radius small enough. Of course, a small radius means slow progress, which is why we want to keep the radius as large as possible as long as the model is good enough to point us in the right direction.</p> <p>In our example, everything went well, we increased the radius and the next iteration looks as follows:</p> <p><img src="/assets/img/tranquilo/animation_2.svg" class="rounded" width="700"></p> <p>Note that we did not have to sample any new points which would have led to expensive new function evaluations. There were enough points in the trustregion to fit a model and everything went well. Never change a winning team!</p> <p>This holds until iteration five where the picture looks as follows:</p> <p><img src="/assets/img/tranquilo/animation_4.svg" class="rounded" width="700"></p> <p>We still have not sampled any new points (except for the candidate points of each iteration) but now we are at the optimum and the expected improvement of the next iteration is very small (in fact, almost zero). To make sure this does not come from the very bad sample quality (all points are almost on a line), we discard some of the existing points and add a new one:</p> <p><img src="/assets/img/tranquilo/animation_5.svg" class="rounded" width="700"></p> <p>Since this still does not change the model, the algorithm has converged.</p> <p>Most real world problems take much longer to converge but the basic steps are the same. While different optimizers differ in the way they choose points and manage the radius, the common theme is to re-use points as efficiently as possible in order to save costly evaluations of the objective function.</p> <h2 id="summary-of-contributions">Summary of Contributions</h2> <p>Tranquilo has two main contributions over similar optimizers such as <a href="https://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf" target="_blank" rel="noopener noreferrer">bobyqa</a>, <a href="https://www.mcs.anl.gov/papers/P5120-0414.pdf" target="_blank" rel="noopener noreferrer">pounders</a>, and <a href="https://dl.acm.org/doi/10.1145/3338517" target="_blank" rel="noopener noreferrer">PyBobyqa and DFO-LS</a></p> <ol> <li>Tranquilo can evaluate the objective function in parallel and has multiple strategies to use otherwise idle cores productively.</li> <li>Tranquilo can estimate the level of noise in the objective function and evaluate and adaptively determine how often the objective function needs to be evaluated at each sample point in order to average out the effects of noise.</li> </ol> <h2 id="parallelization">Parallelization</h2> <p>There are two strategies to utilize otherwise idle cores while running in parrallel: Line search and speculative sampling. Both can be seen best in a plot:</p> <p><img src="/assets/img/tranquilo/line_and_speculative_points.svg" class="rounded" width="700"></p> <p>The line search is triggered when the candidate point is at the border of the trustregion. In that case, the model might propose a search direction that would be valid even if a larger step is taken. So we try out multiple step sizes in parallel.</p> <p>Speculative sampling asks the question: “Which points would we like to encounter in the next iteration, if the candidate was accepted”. In an ideal case, this eliminates or reduces the need to sample points in the next iteration.</p> <p>We benchmark tranquilo against the very efficient serial optimizer DFO-LS on the Moré-Wild benchmark set which is standard in the literature. We vary the number of cores (batch size) between 2 and 8. The y-axis shows the share of solved problems, the x-axis a standardized computational budget in terms of batches.</p> <p><img src="/assets/img/tranquilo/bld/figures/profile_plots/parallelization_ls.svg" class="rounded" width="700"></p> <p>We see that using more cores can dramatically speed up the optimization. Of course, at the cost of using more resources.</p> <h2 id="noise-handling">Noise Handling</h2> <p>To some extent, the only way of getting rid of noise in the objective function is to evaluate it multiple times at each point and average the noise out. Many optimizers do that. The difficult question is: “How many times do we have to evaluate?”. Most existing optimizers leave that task to the user who can specify a (typically increasing) sequence of numbers of evaluations.</p> <p>Tranquilo’s big contribution is to determine that sequence adaptively. Before we look at how tranquilo does that, we take a step back to see why it is a hard problem. Below you can see two plots of the same noisy objective function. The only difference between the two is the trustregion center. The radius and everything else is kept the same. Even the noise draws at each sampling point are kept the same.</p> <p>In the first plot, we are in a steep area of the objective function. Even though we are unlucky in the sense that the noise draw at the highest point is negative and the one at the lowest point is positive, the model does a good job at leading us in the right direction.</p> <p><img src="/assets/img/tranquilo/noise_plot_2.svg" class="rounded" width="700"></p> <p>The only thing that changes in the second plot is that we are in a flat area of the objective function. The same noise draws now lead to a model that sends us straight away from the optimum.</p> <p><img src="/assets/img/tranquilo/noise_plot_3.svg" class="rounded" width="700"></p> <p>An optimal adaptive noise handling strategy would only do one evaluation per point in the first case and multiple evaluations in the second case.</p> <p>The way tranquilo determines how often the objective function needs to be evaluated is based on a simulation. In the simulation, the surrogate model becomes a stand-in for the true objective function and an estimate of the noise variance is used to create simulated noisy evaluations of that criterion function. We then fit simulated surrogate models on those simmulated samples, optimize them and calculate:</p> \[\rho_{noise} = \frac{\text{expected improvement from the simulated model}}{\text{actual improvement in the real model}}\] <p>If \(\rho_{noise}\) is large, we can reduce the number of evaluations per point. If it is small, we increase it. Of course, we repeat the simulation multiple times and work with quantiles of the simulated \(\rho_{noise}\). The mean would not be robust to outliers.</p> <p>This is based on the fundamental insight that the random error due to noise and the approximation error due to a too large trustregion are similar in the sense that they both can decrease the surrogate model’s ability to predict good search directions but we should only take steps against these problems when it actually matters!</p> <p>To determine the number of function evaluations during the acceptance step, we take standard approaches from power analysis. Moreover, we ensure that the acceptance sample is always large enough to get a reliable noise estimate.</p> <p>We compare tranquilo with multiple versions of DFO-LS on Moré-Wild benchmark set with a substantial artificial noise term added to each function. The different versions of DFO-LS use 3, 5 and 10 evaluations at each point. While it is clear that more sophisticated sequences would improve DFO-LS’s performance, there is no good way of coming up with the perfect sequence in practice.</p> <p><img src="/assets/img/tranquilo/bld/figures/profile_plots/noisy_ls.svg" class="rounded" width="700"></p> <p>While no optimizer solves all problems within the computational budget of 5000 function evaluations, we can clearly see that tranquilo has an advantage in speed (it only uses multiple evaluations if necessary) and robustness (It solves more problems).</p> <h2 id="some-more-details">Some more details</h2> <ul> <li>Tranquilo works for scalar objective functions but also can exploit a non-linear least-squares structure, i.e. an objective function of the form \(F(x) = \sum_if_i(x)^2\) and this leads to massive speed-ups. All benchmarks shown here compare optimizers that exploit this structure.</li> <li>Parallelization and noise handling can of course be combined, even though smart strategies for utilizing idle cores become less relevant once tha sample sizes grow large.</li> <li>Tranquilo is available as part of <a href="https://github.com/OpenSourceEconomics/estimagic" target="_blank" rel="noopener noreferrer">estimagic</a> </li> <li>Tranquilo can handle lower and upper bounds on the parameters.</li> <li>Tranquilo is not just a spanish word that describes the algorithm’s ability to make calm and steady progress in the presence of noise but an acronym: <span style="color: #0E4187; font-weight: bold;">T</span>rust<span style="color: #0E4187; font-weight: bold;">R</span>egion <span style="color: #0E4187; font-weight: bold;">A</span>daptive <span style="color: #0E4187; font-weight: bold;">N</span>oise robust <span style="color: #0E4187; font-weight: bold;">QU</span>adrat<span style="color: #0E4187; font-weight: bold;">I</span>c or <span style="color: #0E4187; font-weight: bold;">L</span>inear approximation <span style="color: #0E4187; font-weight: bold;">O</span>ptimizer</li> </ul> <p>A working paper containing all the details will be available soon. Until then, you can check out the presentation slides.</p> <iframe src="https://raw.githack.com/janosg/data/main/tranquilo_slides.pdf" width="700" height="425"></iframe> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Janoś Gabler. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script src="/assets/js/zoom.js"></script> <script src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>